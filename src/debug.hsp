#ifndef IG_UEDAI_DEBUG_HSP
#define IG_UEDAI_DEBUG_HSP

#undef logmes
;#undef assert

#ifdef _DEBUG
#module __debug

//ログを保存するフォルダへのパス
#define global Dir_LogFilePath (dir_mydoc + "/hsp_debug_log.txt")

#uselib "winmm.dll"
#cfunc timeGetTime "timeGetTime"

#define global declvar(%1) if (0) { dim %1 }
#define global __HERE__ ("#" + __LINE__ + " " + __FILE__)
#define global ctype dbgstr(%1) ({"%1 = "} + (%1))
#define global ctype dbgpair(%1, %2) ({"(%1,%2) = ("} + (%1) + ", " + (%2) + ")")
#define global ctype dbghex(%1)  strf({"%1 = 0x%%08X"}, (%1))
#define global ctype dbgchar(%1) strf({"%1 = '%%c'"}, (%1))
#define global ctype dbgcode(%1, %2) (%1)
#define global assert_sentinel logerr "assert sentinel", __HERE__ : assert : end 1

#defcfunc var_type_name int type,  local name, local hvpPtr, local hvp, local prms
	prms = type
	hvpPtr = callfunc(prms, exinfo_at@__debug(25), 1) //HspFunc_getproc
	if ( hvpPtr != 0 ) {
		dupptr hvp, hvpPtr, 20
		if ( hvp(3) != 0 ) {
			dupptr name, hvp(3), 1, vartype("str")
			return name
		}
	}
	assert
	return ""
	
#defcfunc exinfo_at@__debug int idx,  local ctx, local exinfo
	mref ctx, 68
	dupptr exinfo, varptr(ctx(12)), 188
	return exinfo(idx)

//------------------------------------------------
// 出力設定
//------------------------------------------------
#enum global LogMode_Default = 0 //改行区切り
#enum global LogMode_Xml         //書式付き
#enum global LogMode_Max

#enum global LogLevel_Default = 0 //最低
#enum global LogLevel_Notice  = 10
#enum global LogLevel_Warn    = 30
#enum global LogLevel_Error   = 0x7FFF //実際にエラーを起こす

#define global LogEcho_None   0x000
#define global LogEcho_DbgWnd 0x001
#define global LogEcho_File   0x002
#define global LogEcho_All    0xFFF

#deffunc init@__debug
	stt_logPath  = Dir_LogFilePath
	stt_logIndex = 0
	stt_logMode  = LogMode_Default
	stt_logEcho  = LogEcho_All
	stt_logLevel = LogLevel_Default
	sdim  stt_logStr,  4096 //ログメッセージを代入するための一時バッファ
	bsave stt_logPath, stt_logStr, 0 // 上書きして前のデータを削除
	return
	
#define global logmes(%1 = "", %2 = LogLevel_Default, %3 = __HERE__) logmes@__debug str(%1), (%2), (%3)
#deffunc logmes@__debug str msg,  int level, str there,  local len
	if ( level < stt_logLevel ) { return }
	
	//デバッグウィンドウに送る
	if ( stt_logEcho & LogEcho_DbgWnd ) {
		switch ( level )
			case LogLevel_Warn:
				logmes@hsp "[WARNING] " + there
				swbreak
			case LogLevel_Error:
				logmes@hsp "[ERROR!] " + there
				swbreak
		swend
		logmes@hsp msg
	}
	
	//ファイルに書き込む
	if ( stt_logEcho & LogEcho_File ) {
		switch ( stt_logMode )
			case LogMode_Default:
				stt_logStr = msg + "\n"
				swbreak
			case LogMode_Xml:
				stt_logStr = "<log source=\"" + there + "\" time=\"" + timeGetTime() + "\"><![CDATA[" + msg + "]]></log>\n"
				swbreak
		swend
		len = strlen(stt_logStr)
		bsave stt_logPath, stt_logStr, len, stt_logIndex
		stt_logIndex += len
	}
	return
	
#define global logwarn(%1 = "", %2 = __HERE__) logmes@__debug (%1), LogLevel_Warn, (%2)
#define global logerr(%1 = "", %2 = __HERE__) logmes@__debug (%1), LogLevel_Error, (%2)

#define global logvar(%1, %2 = LogLevel_Default, %3 = __HERE__) logvar@__debug (%1), {"%1"}, (%2), (%3), (%4)
#deffunc logvar@__debug var value, str _varname,  int level, str there,  local varname
	varname = _varname : varname = strtrim(varname)
	
	switch ( vartype(value) )
		case vartype("str"):
			if ( instr(value, 0, "\n") >= 0 ) { //複数行文字列の場合
				logmes@__debug strf("%s = {\"%s\"}", varname, value), level, there
			} else {
				logmes@__debug strf("%s = %s", varname, value), level, there
			}
			swbreak
			
		case vartype("double"):
			logmes@__debug strf("%s = %.16f", varname, value), level, there
			swbreak
			
		case vartype("int"):
			logmes@__debug strf("%s = %d\t(0x%08X)", varname, value, value), level, there
			swbreak
			
		default:
			logmes@__debug strf("%s: type %s", varname, var_type_name(vartype(value))), level, there
			swbreak
	swend
	return

#deffunc logmode int mode
	if ( stt_logMode != mode ) {
		logmes@__debug "log mode has changed: " + stt_logMode + " -> " + mode + ".", LogLevel_Notice, "DEBUG"
		stt_logMode = mode
	}
	return

#deffunc logecho int flags
	stt_logEcho = flags
	return

#define global ctype dbgchk_s(%1, %2) dbgchkImpl_s(dbgchkSet_s@__debug(%1), %2, {"%1"}, {"%2"}, __HERE__)
#define global ctype dbgchk_d(%1, %2) dbgchkImpl_d(dbgchkSet_d@__debug(%1), %2, {"%1"}, {"%2"}, __HERE__)
#define global ctype dbgchk_i(%1, %2) dbgchkImpl_i(dbgchkSet_i@__debug(%1), %2, {"%1"}, {"%2"}, __HERE__)

#define ctype FTM_dbgchkImpl(%1) \
	if ( b == 0 ) { \
		logwarn "dbgchk(%1) error\n\texpr: " + x + "\n\tvalue = " + code_value + "\n\tcondition: " + code_condition, there :\
	} :\
	return x ://

#define global dbgchkValue stt_dbgchkValue@__debug

#defcfunc dbgchkSet_s@__debug str x
	dbgchkValue = x : return x
#defcfunc dbgchkSet_d@__debug double x
	dbgchkValue = x : return x
#defcfunc dbgchkSet_i@__debug int x
	dbgchkValue = x : return x
	
#defcfunc dbgchkImpl_s str x, int b, str code_value, str code_condition, str there
	FTM_dbgchkImpl(str)
#defcfunc dbgchkImpl_d double x, int b, str code_value, str code_condition, str there
	FTM_dbgchkImpl(double)
#defcfunc dbgchkImpl_i int x, int b, str code_value, str code_condition, str there
	FTM_dbgchkImpl(int)

#undef FTM_dbgchkImpl

#global

	init@__debug

#else

#define global logmes(%1 = "", %2 = 0, %3 = "", %4 = 0) :
;#define global assert(%1 = 0) :

#define global ctype var_type_name(%1) ""
#define global logmode(%1 = 0) :
#define global loglev(%1 = 0) :
#define global logvar(%1) :
#define global logwarn(%1 = "") :
#define global logerr(%1 = "") :
#define global logecho(%1 = 0) :

#define global __HERE__ ""
#define global declvar(%1) :
#define global ctype dbgstr(%1) ""
#define global ctype dbgpair(%1, %2) ""
#define global ctype dbghex(%1) ""
#define global ctype dbgchar(%1) ""
#define global ctype dbgcode(%1, %2) (%2)
#define global ctype dbgchk_s(%1, %2) (%1)
#define global ctype dbgchk_d(%1, %2) (%1)
#define global ctype dbgchk_i(%1, %2) (%1)
#define global assert_sentinel end 1 //abort

#endif

#endif
